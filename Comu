import multiprocessing
import socket
import datetime
import os
import logging

# Ruta para almacenar los mensajes
ruta_mensajes = os.path.join(os.path.expanduser("~"), "Escritorio", "Mensajes", "mensajes.txt")

# Ruta para el archivo de registro
ruta_registro = os.path.join(os.path.expanduser("~"), "Escritorio", "Mensajes", "actividad.log")

# Variable global para el identificador del mensaje
id_mensaje = 0

# Definición de la función para enviar mensajes
def enviar_mensaje(nodo_destino, mensaje):

  global id_mensaje

  # Crear un socket para la conexión
  sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
   
  # Conectarse al nodo destino
  try:
    sock.connect((nodo_destino, 5000))
  except ConnectionRefusedError:
    print(f"Error: No se pudo conectar al nodo {nodo_destino}.")
    return
   
  # Obtener el tiempo del reloj
  tiempo_envio = datetime.datetime.now()
   
  # Incrementar el identificador del mensaje
  id_mensaje += 1
   
  # Enviar el mensaje
  mensaje_completo = f"{id_mensaje}|{tiempo_envio}|{mensaje}"
  sock.sendall(mensaje_completo.encode())
   
  # Recibir la respuesta de recibido
  try:
    respuesta = sock.recv(1024).decode()
  except ConnectionResetError:
    print(f"Error: Se perdió la conexión con el nodo {nodo_destino}.")
    return
   
  # Cerrar el socket
  sock.close()
   
  # Imprimir la respuesta
  print(f"Respuesta de {nodo_destino}: {respuesta}")

  # Registrar la actividad
  logger.info(f"Enviando mensaje | {id_mensaje} | {nodo_destino}")

# Definición de la función para recibir mensajes
def recibir_mensajes():

  # Crear un socket para la recepción
  sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
   
  # Enlazar el socket a la dirección y puerto
  sock.bind(('', 5000))
   
  # Escuchar por conexiones
  sock.listen()
   
  while True:
    # Aceptar una conexión
    try:
      conn, addr = sock.accept()
    except OSError as e:
      print(f"Error al aceptar la conexión: {e}")
      continue
     
    # Recibir el mensaje
    try:
      mensaje_completo = conn.recv(1024).decode()
    except (ConnectionResetError, TimeoutError) as e:
      print(f"Error: {e.__class__.__name__} con el nodo {addr[0]}.")
      continue
     
    # Separar el identificador del mensaje, el tiempo y el mensaje
    id_mensaje, tiempo_envio, mensaje = mensaje_completo.split("|")
     
    # Almacenar el mensaje
    with open(ruta_mensajes, "a") as f:
      f.write(f"{id_mensaje}|{tiempo_envio}|{addr[0]}|{mensaje}\n")

    # Registrar la actividad
    logger.info(f"Recibiendo mensaje | {id_mensaje} | {addr[0]}")

# Cerrar la conexión
conn.close()

# Obtener el nombre del nodo actual
nombre_nodo = socket.gethostname()

# Configurar el logger
logger.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s | %(levelname)s | %(message)s')
file_handler = logging.FileHandler(ruta_registro)
file_handler.setFormatter(formatter)
logger.addHandler(file_handler)

# Iniciar el proceso de recepción de mensajes
proceso_recepcion = multiprocessing.Process(target=recibir_mensajes)
proceso_recepcion.start()

# Bucle para enviar mensajes
while True:
  # Introducir el nombre del nodo destino
  nodo_destino = input("Introduzca el nombre del nodo destino: ")
   
  # Introducir el mensaje
  mensaje = input("Introduzca el mensaje: ")
# Enviar el mensaje
enviar_mensaje(nodo_destino, mensaje)

